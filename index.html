<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Play Chess</title>
<script src="./socket.io/socket.io.js"></script>
<script type="module" src="./src/ui/HTMLChessBoardElement.js"></script>
</head>
<body>
<link rel="stylesheet" type="text/css" href="./all.css">
<main>
	<chess-board id="chessBoard" labels></chess-board>
	<fieldset id="chessHistory" data-type="History"></fieldset>
</main>
<script type="module">

import { Game, GameUiBridge } from './index.js';

let gameUi = window.gameUi = null;
let game = window.game = null;

class SioGameUiBridge extends GameUiBridge {
	static async create({ chessBoard, chessHistory, socket, gameId, userId }) {
		socket.call = function (funcName, ...args) {
			return new Promise((resolve, reject) => {
				this.emit(funcName, ...args, function (err, res) {
					if (err) {
						reject(err);
					}
					else {
						resolve(res);
					}
				});
			});
		};
		
		const pgn = await socket.call('joinGame', gameId);
		const game = await Game.parsePgn(pgn);
		const gameUi = new this({
			game,
			elBoard: chessBoard,
			elHistory: chessHistory,
		});
		await game.seekEnd();
		gameUi.socket = socket;
		gameUi.gameId = gameId;
		gameUi.userId = userId;
		
		if (game.meta.White === userId) {
			gameUi.playWhite = true;
		}
		else if (game.meta.Black === userId) {
			gameUi.playWhite = false;
		}
		gameUi.elBoard.swap = gameUi.playWhite === false;
		
		socket.on('joined', (meta) => console.log('joined', meta));
		
		socket.on('applyMove', async (gameId, moveAbbr, curPos) => {
			if (game.meta.Id !== gameId) {
				return;
			}
			console.log('applyMove', moveAbbr);
			const isMainLast = game.isMainLast;
			const lastPos = game.pos;
			await game.setPos(curPos);
			const move = game.applyMove(moveAbbr);
			if (game.isMainLast !== isMainLast) {
				await game.setPos(lastPos);
			}
		});
		
		return gameUi;
	}

	getPlayWhite() {
		if (this.game.isMainLast) {
			return this.playWhite;
		}
		return this.game.activeWhite;
	}

	async beforeApplyMove(move, curPos) {
		if (move.mut) {
			while (true) {
				move.mut = prompt("Mutate piece", 'Q') || '';
				if ('QRNB'.indexOf(move.mut.toUpperCase()) > -1) {
					break;
				}
			}
		}
		move = await socket.call('applyMove', this.game.meta.Id, move.toString(), curPos);
		if (this.game.isMainLast) {
		}
		return move;
	}
}

localStorage.token = localStorage.token || randomString(16);
const userId = localStorage.token.slice(0, 8);
let playWhite = null;

const socket = io('/', {
	query: {
		token: localStorage.token,
	},
});


const params = new URLSearchParams(document.location.search);
const gameId = params.get('gameId');
if (!gameId) {
	params.set('gameId', randomString(16));
	document.location.href = new URL('?' + params, document.location.href).toString();
}

gameUi = window.gameUi = SioGameUiBridge.create({
	chessBoard,
	chessHistory,
	socket,
	gameId,
	userId,
});
game = window.game = gameUi.game;

////////////////

function randomString(len) {
	const c = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
	let res = '';
	while (res.length < len) {
		res += c[Math.round(Math.random() * c.length) % c.length];
	}
	return res;
}

</script>
</body>
</html>
